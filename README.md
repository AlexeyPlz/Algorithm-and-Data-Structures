# Базовые знания с абстракцией от [AlexeyPlz](https://github.com/AlexeyPlz)
## Глава 1. База
### Тема 1.1 Парадигмы программирования
Существует много парадигм программирования, однако среди этого разнообразия можно выделить три основных:
- Структурное программирование.
- Функциональное программирование.
- Объектно-ориентированное программирование.

Структурное программирование несёт в себе 2 идеи:
- Программа должна строиться без использования оператора goto.
- В основе программы должны лежать 3 конструкции: последовательность, ветвление и цикл.

Функциональное программирование несёт в себе 4 идеи:
- В функциональном программировании нельзя изменять переменную после её инициализации, можно лишь создавать новые.
- В функциональном программировании применяются чистые функции (нет side effects и функция всегда возвращает одно и тоже при одинаковых аргументах).
- В функциональном программировании вместо циклов применяют рекурсию.
- В функциональном программировании применяются функции высших порядков — функции, которые могут принимать функции в качестве аргументов и возвращать другие функции.

Объектно-ориентированное программирование несёт в себе 5 идей:
- Класс - универсальный, комплексный тип данных, состоящий из тематически единого набора «атрибутов» (переменных более простых типов) и «методов» (функций для работы с атрибутами).
- Объект - экземпляр класса, сущность, которой можно посылать сообщения и которая может на них реагировать, используя свои данные.
- Инкапсуляция - свойство системы, позволяющее объединить в объекте и данные, и методы для работы с ними. Данные объекта скрыты от остальной программы.
- Наследование - свойство системы, позволяющее описать новый класс на основе уже существующего, и при этом частично или полностью заимствовать функциональность родителя.
- Полиморфизм — возможность единообразно обрабатывать объекты с различной реализацией при условии наличия общего интерфейса.
### Тема 1.2 SOLID
Для ООП сформулированы пять базовых принципов, каждый из которых описывает целый класс шаблонов и подходов.  
- SRP (Single responsibility principle) — принцип единственной ответственности.
- OCP (Open-closed principle) — принцип открытости/закрытости.
- LSP (Liskov substitution principle) — принцип подстановки Барбары Лисков.
- ISP (Interface segregation principle) — принцип разделения интерфейса.
- DIP (Dependency inversion principle) — принцип инверсии зависимостей.

<b>Принцип единственной ответственности</b>  
Для каждого класса должно быть определено его единственное назначение.  
Все ресурсы, необходимые для реализации этого назначения, должны быть инкапсулированы в этот класс и подчинены единственной задаче.  
Если класс имеет несколько назначений, его нужно разделить на отдельные классы.

<b>Принцип открытости/закрытости</b>  
Программные сущности должны быть открыты для расширения, но закрыты для модификации.

<b>Принцип подстановки Барбары Лисков</b>  
Объекты в программе должны быть заменяемыми на экземпляры их подтипов — и при этом программа должна выполняться без ошибок.  

<b>Принцип разделения интерфейса</b>  
Интерфейс — это совокупность методов и правил взаимодействия элементов системы, способ взаимодействия с программным объектом.  
Большое количество интерфейсов лучше, чем один интерфейс общего назначения.  
Это означает, что большие интерфейсы нужно разбивать на более мелкие, не содержащие избыточных методов и которые конкретному клиенту просто не нужны.  
Как следствие, можно будет менять разные интерфейсы независимо один от другого, не опасаясь вывести из строя сразу всё.  

<b>Принцип инверсии зависимостей</b>  
Высокоуровневые модули не должны зависеть от низкоуровневых модулей.  
Высокоуровневые и низкоуровневые модули должны зависеть от абстракций.  
Абстракции не должны зависеть от деталей.  
Детали должны зависеть от абстракций.  
Под словом «модуль» здесь понимается взаимосвязанная совокупность функциональных элементов.  
Это может быть класс, программный модуль (библиотека, подпрограмма) или даже фреймворк.

### Тема 1.3 KISS. DRY. YAGNI.
<b>YAGNI</b> - You Aren’t Gonna Need It  
<b>DRY</b> - Don’t Repeat Yourself  
<b>KISS</b> - Keep It Simple, Stupid

## Глава 2. Сети
- ToDo
## Глава 3. Процессор
- ToDo
## Глава 4. Память
### Тема 4.1. Основы
Память - это компонент компьютера, способный хранить в себе различную информацию.  
Память бывает разная, быстрая и медленная. Ниже приведена таблица с примерами:
|Тип памяти|Время|Объем|Информация|
|:-------:|:-------:|:-------:|:-------:|
|Регистры|10/10|1/10|Находится на самом процессоре. Она используется для сохранения инструкций, с которыми процессор будет работать|
|Кэш|8/10|2/10|Многоуровневое хранилище в процессоре для часто используемых данных.|
|Оперативная память|5/10|5/10|Память, где хранятся программы, которые работают в данный момент времени, и их данные.|
|Внешние накопители|2/10|10/10|Жёсткие диски, флешки и т.д.|
### Тема 4.2. Оперативная память
Оперативная память разбита на ячейки размером 1 байт.  
Один байт содержит в себе 8 бит. Каждый бит может принимать одно из двух значений: 0 или 1.  
Получается в ячейку можно записать 2<sup>8</sup> = 256 вариантов значений: от 0 до 255.  
То есть 1 байт может содержать в себе любую букву латиницы, кириллицы, специальный символ или цифру от 0 до 255.
- Бит - минимальная единица хранения информации.  
- Байт - минимальная ячейка адресации.  

Каждая ячейка читается справа налево. Самый младший бит (разряд) - 0, самый старший бит (разряд) - 7.  
Ниже приведен пример ячейки. В первой строке адрес, во второй двоичный код, а в последней разряд.
|||0|x|0|1|||
|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|
|0|1|0|1|0|1|0|1|
|7|6|5|4|3|2|1|0|
### Тема 4.3. Адресация
Каждая ячейка имеет свой порядкой номер - адрес. Именно адреса ипользует процессор для обращения к данным.
- Адресация - осуществление ссылки (обращения) к элементу данных по адресу.  

Виды адресации:
- Байтовой адресацией - адресация, относящаеся к аппаратной архитектуре, где каждый байт имеет свой адрес(пример выше).
- Словесная адресация - адресация, относящиеся к словесно-адресуемым архитектурам, где каждая ячейка равна машинном слову: 32 или 64 бита, например.  

Пример байтовой адресации:
|0х01|0х02|0х03|0х04|
|:-------:|:-------:|:-------:|:-------:|
|A|L|E|X|

Пример словесной адресации в 32-разрядной системе:
|0x01|
|:-------:|
|ALEX|

Как правило, все компьютеры имеют байтовую адресацию.  
Словесная адресация применяется, как правило, в научных целях, где необходимо проводить расчёт с большими числами, например.
- Машинное слово - это максимальное количество бит, которыми может оперировать процессор за раз, обмениваться ими с ОЗУ, хранить их в регистрах и т.д.
### Тема 4.4. Хранение байт в памяти
Байты в памяти могут распологаться в прямом порядке (big endian) и обратном порядке (little endian).
### Тема 4.5. Размер оперативной памяти
Почему мы можем или не можем иметь ограничение в количестве ОЗУ?  
Всё упирается в регистр процессора и разрядность системы.  
Каждый имел дело с 32 и 64-разрядной системой.  
Каждый байт памяти должен иметь свой адрес. И как раз таки количество адресов имеет ограничение.  
Если регистр на 8 бит, то максимальный объем памяти 2<sup>8</sup> = 256 байт.  
Если регистр на 16 бит, то максимальный объем памяти 2<sup>16</sup> = 65536 байт = 64 Мбайт.  
Если регистр на 32 бит, то максимальный объем памяти 2<sup>32</sup> = 4294967296 байт = 4096 Мбайт = 4 Гб.  
Если регистр на 64 бит, то максимальный объем памяти 2<sup>64</sup> = 1,844674407×10<sup>19</sup> байт = ... = 16 Тб.
### Тема 4.6. Почему 8 бит  
На самом деле байт может иметь любое количество битов, но всё связанно с первыми стандартами кодирования символов.  
Их целью была кодировка букв латиницы, так как вся работа практически была с текстом.  
Поэтому в первых кодировках для одного символа хватало 6 бит.  
Но при проектировании компьютеров оказалось, что реализация 6 битной ячейки не такая простая и проще реализовать 8 битную.  
При это дополнительные 2 бита не использовались, кодировка и дальше была на 6 битах, пока не появился новый стандарт ASCII с 7 битами.  
Также это ответ почему байт не имеет более 8 бит. Здесь уже необходимо говорить о нецелесообразности использования большего количества бит, так как в любом случае часть битов просто не используется.
### Тема 4.7. Кодировки
Все современные кодировки основаны на ASCII. Она содержит в себе 2<sup>7</sup> = 128 символов: от 0 до 127.  
Позже появились и другие кодировки,например UTF-8, которые расширяют диапазон от 128 до 255. То есть уже испольуют все 8 бит.  
В UTF-8 содержится, например, кириллица.
Существую более сложные кодировки на 2 и более количество байт.
## Глава 5. Сложности алгоритмов
- O(1) - константная зависимость
- O(log* n) - итерированно логарифмическая зависимость
- O(log(log n)) - дважды логарифмическая зависимость
- O(log n) - логарифмическая зависимость
- O(n<sup>с</sup>), где 0<c<1 - сублинейная зависимость
- O(n) - линейная зависимость
- O(n·log* n) - линейно-итерированно логарифмическая зависимость
- O(n·log n) - линейно-логарифмическая зависимость
- O(n<sup>2</sup>) - квадратичная зависимость
- O(n<sup>3</sup>) - кубическая зависимость
- O(2<sup>n<sup>ε</sup></sup>), где ε>0 - cубэкспоненциальная зависимость (Первое определение)
- 2<sup>o(n)</sup> - cубэкспоненциальная зависимость (Второе определение)
- 2<sup>O(n)</sup> - экспоненциальная зависимость (С линейной экспонентной)
- O(2<sup>n</sup>) - экспоненциальная зависимость
- O(!n) - факториальная зависимость
- O(2<sup>2<sup>n</sup></sup>) - дважды экспоненциальная зависимость
## Глава 6. Алгоритмы и структуры
- [Двоичная система](./Binary#readme)
- [Поиск](./Search#readme)
- [Сортировка](./Sorting#readme)
- [Структуры](./Structures#readme)